## 前言

本文介绍定位和分析`DA14531`收包流程的方法，并提供简单的BLE协议漏洞挖掘思路。

## 定位收包函数

通过查看`DA14531`的芯片手册，我们知道这个芯片使用的CPU是 `Arm Cortex-M0+`，我们知道`M0`的异常向量表位于0地址处，所以我们去看看`DA14531`手册的`memory map` 一节中是怎么定义0这个地址的。

![1611668769467](images/1611668769467.png)

可以看到地址空间 `[0, 0x4000000]` 的描述如下

```
Remapped address space based on SYS_CTRL_REG[REMAP_ADR0].
```

看意思感觉是**0地址**这块区域会根据`SYS_CTRL_REG[REMAP_ADR0]`的值被重新映射。

在手册中搜索`SYS_CTRL_REG`，可以找到`REMAP_ADR0`的定义

![1611668912556](images/1611668912556.png)可以看到`REMAP_ADR0`的取值不同会把不同的区域重映射到0地址处，这里以值为 `0x2` 为例，此时会把`RAM` (`SysRAM1`)这块区域映射到**0地址**，查看memory map可以知道这款区域的详细信息

```
SysRAM1 (16 kB): 0x07FC0000 to 0x07FC3FFF
```

所以`0x07FC0000`开头就存放着异常向量表， 实际上开发者使用`DA14531`芯片的`SDK`编译出来的软件就是烧写在这个区域，自己编译一个软件，然后加载到IDA既可拿到异常向量表的信息

![1611669271841](images/1611669271841.png)

找到异常向量表后，可以去翻翻手册，看看`DA14531`使用的中断的类型和描述

![1611669383450](images/1611669383450.png)

可以看的 `IRQ #1` 的 `BLE_GEN_IRQn`中断感觉和蓝牙收发包相关，其中`LE_RX_IRQn`中断在每个数据包接收完毕后触发。

然后我们去异常向量表中找到 `IRQ #1` 的处理函数，由于M0芯片的内置异常为16个，所以 `IRQ #1` 的处理函数为`rwble_isr`。

## 收包流程分析

`rwble_isr`函数入口会对`40000xxx`的地址进行访问

```
void rwble_isr()
{
  if ( unk_40000200 << 31 )
  {
    unk_40000200 |= 2u;
  }
  if ( (unk_40000200 & 0x400000) != 0 )
  {
    unk_40000200 |= 0x400000u;
```

可以在`SDK`中搜索这些地址，拿到地址的信息，比如`0x40000200`地址处是蓝牙的控制寄存器

```
#define BLE_CNTL2_REG                        (0x40000200) /* BLE Control Register 2 */
```

逆向了一小会后发现`rwble_isr`函数的源码在`SDK`中，可以直接查看，和收包相关的代码如下

```
__BLEIRQ void rwble_isr(void)
{
    // Loop until no more interrupts have to be handled
    while (1)
    {
        // Check BLE interrupt status and call the appropriate handlers
        uint32_t irq_stat = ble_intstat_get();
        if (irq_stat == 0)
            break;
        // Rx interrupt
        if (irq_stat & BLE_RXINTSTAT_BIT)
        {
            DBG_SWDIAG(BLE_ISR, RXINT, 1);

            ble_intack_clear(BLE_RXINTSTAT_BIT);

            dlg_rx_isr();

            DBG_SWDIAG(BLE_ISR, RXINT, 0);
        }
```

函数首先调用`ble_intstat_get` 读取中断状态，然后根据`irq_stat`中的二进制位判断中断的类型（感觉和Linux的共享`IRQ`机制类似），如果有`BLE_RXINTSTAT_BIT`表示是收包中断，会调用 `dlg_rx_isr` 处理收包事件。

`dlg_rx_isr`函数实际调用的是`lld_evt_rx_isr`，`lld_evt_rx_isr` 会进入 `lld_evt_rx` 函数

```
void __fastcall lld_evt_rx(lld_evt_tag *elt)
{
  v1 = elt + 1;
  v2 = *(82 * LOWORD(elt[1].anchor_point.basetime_cnt) + *off_7F09820 + 0x114) >> 12;// ble_cntl_get
  add_evt_deferred_tag(elt, 0, v2);
  HIBYTE(v1->tx_prog.maxcnt) += v2;
  ke_event_set(5u);
}
```

主要就是触发 `#5` 号事件去完成具体的收包过程，该事件的回调函数在lld_evt_init中注册

```
int __fastcall lld_evt_init(int a1, int a2, int a3, int a4)
{
	...................
	...................
	return ke_event_callback_set(5u, lld_evt_deffered_elt_handler);
}
```

因此会进入`lld_evt_deffered_elt_handler`进行下一步数据包的处理，其主要代码如下

```
int lld_evt_deffered_elt_handler(int a1, int a2, int a3, int a4)
{
    ke_event_clear(5u);
    while ( 1 )
    {
    	// 取出packet的结构
        pkg_info = get_recv_pkg_info(&v11, &rx_cnt);

        // 0x200 的回调函数 0x7F0581B, 0x7F0CB37
        msg_data = ke_msg_alloc(0x200, dest_id, 2u, 6u);
        
        // 填充msg_data里面的数据包相关信息
        lld_data_rx_check((pkg_info_1 + 36), msg_data, rx_cnt);
        
        // 消息回调函数处理数据
        ke_msg_send(msg_data);                    
    }

    return pkg_info;
}
```

首先清除`#5`号事件，然后从全局链表中取出一个包的信息，然后发送一个 `msg_id` 为 `0x200` 消息，消息的`param`部分由 `lld_data_rx_check` 填充，`param`的结构体定义如下

```
struct lld_data_ind
{
    /// Handle of the first RX buffer
    uint8_t rx_hdl;
    /// Number of received buffers
    uint8_t rx_cnt;
    /// Number of transmitted data buffers
    uint8_t tx_cnt;
    /// Number of transmitted data control buffers
    uint8_t tx_cnt_cntl;
    /// Event counter
    uint16_t evt_cnt;
};
```

可以看到 `rx_hdl` 和 `rx_cnt` 用于表示收到的数据包的信息，`msg_id`为`0x200`的处理函数有两个

```
0x7F0581B  llc_0x200_id_handler
0x7F0CB37  llm_0x200_id_handler
```



### llm_0x200_id_handler

该函数用于处理 `ADVERTISING CHANNEL PDU`， 经过简化的关键代码如下

```
int __fastcall llm_0x200_id_handler(int msg_id_1, lld_data_ind *param, int dest_id, int src_id)
{

  rx_cnt = param->rx_cnt;
  rx_hdl = param->rx_hdl;

  while ( 1 )
  {

    // 根据 rx_hdl 找到对应数据包描述符
    rx_desc = (v26[4] + 10 * rx_hdl);

    // 根据包描述符得到 实际数据包在内存的地址
    pkg_data = co_buf_rx_buffer_get(rx_desc);
    idx = 0;
    pkg_data_1 = pkg_data;

    // 从全局变量里面取 6 个字节的保存到 device_addr
    do
    {
        device_addr[idx] = *(*ble_base_2[0] + idx + 0x115);
        idx = (idx + 1);
    }
    while ( idx < 3 );

    // 搜索和 device_addr 匹配的数据包
    while ( rx_cnt && memcmp(device_addr, pkg_data_1, 6) )
    {
        co_buf_rx_free(rx_hdl);
        rx_hdl = (rx_hdl + 1) & 7;
        rx_desc = (v26[4] + 10 * rx_hdl);
        rx_cnt = (rx_cnt - 1);
        pkg_data_1 = co_buf_rx_buffer_get(rx_desc);
    }

    // 根据数据包的类型进行对应的处理
    switch ( rx_desc->rxheader & 0xF )  // llm_util_rxtype_getf
    {
    case 0:
    case 1:
    case 2:
    case 4:
    case 6:
        llm_le_adv_report_ind(rx_desc);
        break;
    case 3:
        llm_le_scan_report_ind(rx_desc);
        break;
    case 5:
        llm_con_req_ind(rx_desc);
        break;
    default:
        break;
    }
  }
```

代码逻辑

1. 首先从param里面取出rx_cnt和rx_hdl，然后根据rx_hdl得到对应数据包描述符rx_desc
2. 然后会去全局变量里面拷贝6个字节保存到device_addr，然后会从rx_hdl开始遍历rx_cnt个数据包，直到找到包头6个字节和device_addr相同的数据包为止。
3. 然后通过rxheader中的数据包类型来进行调用相应的函数进行进一步的处理

rx_desc的结构定义如下

```
struct co_buf_rx_desc
{
    /// rx pointer
    uint16_t rxptr;
    /// status
    uint16_t rxstatus;
    /// rx header
    uint16_t rxheader;
    /// rx chass
    uint16_t rxchass;
    /// rx data pointer
    uint16_t rxdataptr;
};
```

其中`rxdataptr`指向存放蓝牙数据的位置，需要通过`co_buf_rx_buffer_get`将其转换为实际的内存地址

```
uint8_t *__fastcall co_buf_rx_buffer_get(struct co_buf_rx_desc *rx_desc)
{
  return (rx_desc->rxdataptr + *ble_base_1);
}
```

rxheader中包含了该数据包的类型、长度等信息，在SDK中搜索rxheader的引用，可以找到如下函数来推测rxheader的含义

```
#define BLE_RXADVLEN_MASK   ((uint16_t)0x0000FF00)
#define BLE_RXADVLEN_LSB    8

#define BLE_RXTYPE_MASK     ((uint16_t)0x0000000F)
#define BLE_RXTYPE_LSB      0

// 返回 rxdesc 数据包的长度
uint8_t llm_util_rxlen_getf(struct co_buf_rx_desc *rxdesc)
{
    uint16_t localVal =  rxdesc->rxheader;
    return ((localVal & BLE_RXADVLEN_MASK) >> BLE_RXADVLEN_LSB);
}

// 返回数据包的类型
uint16_t llm_util_rxtype_getf(struct co_buf_rx_desc *rxdesc)
{
    uint16_t localVal =  rxdesc->rxheader;
    return ((localVal & BLE_RXTYPE_MASK) >> BLE_RXTYPE_LSB);
}
```

通过分析这些函数的含义和对rxheader的使用可以知道rxheader中一些字段的含义

```
高字节表示数据包的长度
低4位表示数据包的类型
```

PS:后面分析其他的部分时，反推得到`rxheader`其实就是 ADV PDU Header， 其格式如下

![](images/adv-header.png)

通过分析`llm_con_req_ind`和 BLE 5.0 的协议规范，可以知道 `pkg_data` 指向的是**Uncoded PHY 空口包的 PDU 部分**.

![](images/air-packet-struct.png)

翻看了`2.3 ADVERTISING CHANNEL PDU`中的所有PDU类型，除了采用Common Extended Advertising Payload Format格式的PDU外，其他的`PDU`的头6个字节都是`AdvA`，表示发送广播的设备地址。因此该函数开头就是在根据数据包的`AdvA`来查找到对应设备发送的数据包。

### llc_0x200_id_handler

从上一节的分析我们知道`llm_0x200_id_handler`用于处理`ADVERTISING CHANNEL PDU`， 根据协议的规范，`llc_0x200_id_handler`函数应该就是用于处理DATA CHANNEL PDU报文，协议规范定义如下

![](images/data-channel-pdu.png)

可以看的PDU由2字节的`header`和`payload`组成，其中`header`的结构定义如下：

![](images/data-channel-pdu-header.png)

下面分析和数据包相关的代码

```
int llc_0x200_id_handler(int msg_id, lld_data_ind *data, unsigned int dest_id, int src_id)
{
    rx_cnt = data->rx_cnt;                        // 收到数据包的数目
    first_rx_handle = data->rx_hdl;               // Handle of the first RX buffer
    task_index = dest_id >> 8;

    llid = rx_desc->rxheader & 3;             
    // LL Data PDU
    if ( llid == LLID_CONTINUE || llid == LLID_START )
    {
        llc_data_rcv(task_index, first_rx_handle);
    }
    else
    {
        // LL Control PDU
        if ( llid != LLID_CNTL ) 
        {
            goto LABEL_58;
        }
        llc_cntl_rcv(task_index, first_rx_handle);
    }
```

主要是根据`rxheader`的`LLID`字段来判断数据包的类型，如果是`LL Data PDU`就调用`llc_data_rcv`处理，如果是控制`PDU`就使用`llc_cntl_rcv`处理。

#### llc_data_rcv

函数主要代码如下

```
void llc_data_rcv(uint16_t conhdl, uint8_t hdl)
{
  idx = conhdl;
  rxdesc = (off_7F047E4[0][4] + 10 * hdl);
  msg_data = ke_msg_alloc(0x100u, (conhdl << 8) + 1, (conhdl << 8) + 1, 8u);
  msg_data->task_index = idx;
  llc_env_tag_tbl = off_7F047E8;
  pkg_length = HIBYTE(rxdesc->rxheader);
  msg_data->pkg_length = pkg_length;
  if ( (llc_env_tag_tbl[idx]->enc_state & 2) != 0 )
  {
    msg_data->pkg_length = pkg_length - 4;
  }
  msg_data->llid = rxdesc->rxheader & 3;
  msg_data->hdl = hdl;
  ke_msg_send(msg_data);
}
```

1. 首先获取到数据包的描述符`rxdesc`
2. 申请一个消息id为`0x100`的消息，并将数据包的长度、hdl等信息填入消息数据中
3. 最后将消息发送出去

该消息的处理函数为 `sub_7F05D20`（`0x07F05D20`），主要就是修改消息的`id`（0x806）和`dest_id`，然后使用`hci_send_2_host`让消息处理函数去进一步处理

```
int __fastcall sub_7F05D20(int a1, llc_0x100_struct *msg_data, unsigned int a3)
{
 
    msg_hdr = CONTAINING_RECORD(msg_data, ke_msg, param);
    msg_hdr->id = dw_0x806;
    msg_hdr->dest_id = v4;
    hci_send_2_host(msg_data);                  // 0x7F13D97,hci_acl_data_rx_handler
```

`0x806`的消息处理函数为`hci_acl_data_rx_handler`，该函数处理的数据就是`l2cap`的协议数据了。

#### llc_cntl_rcv

该函数用于处理LL Control PDU，其BLE规范定义如下

![](images/ll-control-pdu.png)

主要就是一个字节的opcode和ctrdata，函数主要代码如下

```
int __fastcall llc_cntl_rcv(int idx, int rx_hdl)
{
 
    rxdesc = (off_7F0478C[4] + 10 * rx_hdl);
    pkg_length = HIBYTE(rxdesc->rxheader);
    // 取出 opcode
    opcode = *co_buf_rx_buffer_get(rxdesc); 
  	
  	// 根据opcode找到回调函数进行处理
    tbl_index = 8 * opcode;
    v9 = llc_handler_tbl;
    msg_data = ke_msg_alloc(*(v7 + 4), dest_id, dest_id, *(v7 + 7));
    pkg = co_buf_rx_buffer_get(rxdesc);
    (*(v9 + tbl_index))(pkg, pkg_length, msg_data);
    v8 = msg_data;

    ke_msg_send(v8);
```

主要就是获取数据包的opcode，然后根据`opcode`找到对应的函数对数据包进行处理

回调函数表的结构如下

![1612358563014](images/1612358563014.png)

## 漏洞挖掘思路与示例

理清楚数据流动后，就可以开展漏洞挖掘了，漏洞挖掘手段主要就是源码审计和Fuzz测试。

如果是静态源码审计就是跟踪外部的数据流，分析程序在处理数据时是否存在问题，比如长度没做校验等，关注的问题主要有数据中长度字段、偏移字段的校验，内存拷贝是否存在越界、资源的分配、使用于释放是否配对等。

如果是要做Fuzz测试的话，就需要识别出处理数据的函数，对其进行适配，比如使用Unicorn将其模拟执行起来，然后使用AFL对其进行Fuzzing.或者可以采用一些蓝牙的发包器，自己写Fuzzer或者采用Peach等工具进行黑盒的Fuzzing.

### llm_con_req_ind越界读漏洞

前面我们分析到llm_0x200_id_handler函数主要用于处理 `ADVERTISING CHANNEL PDU`，函数首先根据数据包的`AdvA`找到需要处理的数据包，然后如果数据包类型是`LL_CONNECT_REQ`就会进入`llm_con_req_ind`进行处理

```
      switch ( rx_desc->rxheader & 0xF )
      {
        case LL_CONNECT_REQ:
            llm_con_req_ind(rx_desc);
```

llm_con_req_ind函数里面没有检查数据包的长度，直接将其当作一个llm_pdu_con_req_rx结构体进行访问，比如：

```
  ar = data->latency;
  if ( ar > 500
    || (v3 * 5 * (ar + 1) + 1) >> 1 > 10 * var
    || !data->chm.map[0] && !data->chm.map[1] && !data->chm.map[2] && !data->chm.map[3] && !(data->chm.map[4] << 27) )
  {
    return;
```

如果数据包实际长度小于结构体的大小就会导致越界读。

## 总结

本文主要介绍了DA14531芯片BLE底层协议栈（LL层和L2CAP）收包处理，并提供挖掘BLE协议栈漏洞的思路，其实和普通漏洞挖掘没有太大区别，关键是定位污点数据，然后就是常规的源码分析和Fuzz测试技术的运用。



## 参考链接

```
https://blog.csdn.net/zhoutaopower/article/details/95104632
```

