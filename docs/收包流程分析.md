

## 定位收包函数

通过查看`DA14531`的芯片手册，我们知道这个芯片使用的CPU是 `Arm Cortex-M0+`，我们知道`M0`的异常向量表位于0地址处，所以我们去看看`DA14531`手册的`memory map` 一节中是怎么定义0这个地址的。

![1611668769467](images\1611668769467.png)

可以看到地址空间 `[0, 0x4000000]` 的描述如下

```
Remapped address space based on SYS_CTRL_REG[REMAP_ADR0].
```

看意思感觉是**0地址**这块区域会根据`SYS_CTRL_REG[REMAP_ADR0]`的值被重新映射。

在手册中搜索`SYS_CTRL_REG`，可以找到`REMAP_ADR0`的定义

![1611668912556](images\1611668912556.png)可以看到`REMAP_ADR0`的取值不同会把不同的区域重映射到0地址处，这里以值为 `0x2` 为例，此时会把`RAM` (`SysRAM1`)这块区域映射到**0地址**，查看memory map可以知道这款区域的详细信息

```
SysRAM1 (16 kB): 0x07FC0000 to 0x07FC3FFF
```

所以`0x07FC0000`开头就存放着异常向量表， 实际上开发者使用`DA14531`芯片的`SDK`编译出来的软件就是烧写在这个区域，自己编译一个软件，然后加载到IDA既可拿到异常向量表的信息

![1611669271841](images\1611669271841.png)

找到异常向量表后，可以去翻翻手册，看看`DA14531`使用的中断的类型和描述

![1611669383450](images\1611669383450.png)

可以看的 `IRQ #1` 的 `BLE_GEN_IRQn`中断感觉和蓝牙收发包相关，其中`LE_RX_IRQn`中断在每个数据包接收完毕后触发。

然后我们去异常向量表中找到 `IRQ #1` 的处理函数，由于M0芯片的内置异常为16个，所以 `IRQ #1` 的处理函数为`rwble_isr`。

## 收包流程分析

`rwble_isr`函数入口会对`40000xxx`的地址进行访问

```
void rwble_isr()
{
  if ( unk_40000200 << 31 )
  {
    unk_40000200 |= 2u;
  }
  if ( (unk_40000200 & 0x400000) != 0 )
  {
    unk_40000200 |= 0x400000u;
```

可以在`SDK`中搜索这些地址，拿到地址的信息，比如`0x40000200`地址处是蓝牙的控制寄存器

```
#define BLE_CNTL2_REG                        (0x40000200) /* BLE Control Register 2 */
```











