# 概述

DA145x软件平台利用了由Riviera Waves许可的小型高效实时内核。 内核提供以下功能：

1. 任务创建和状态转换。
2. 任务之间的消息交换。
3. 计时器管理。
4. 动态内存分配。
5. BLE事件的调度和处理

# 基础数据结构



## co_list链表实现

### 数据结构

co_list就是一个单向链表，DA145x代码里面会使用co_list来存放各种数据，比如消息数据.

核心的数据结构如下

```
//链表中的节点
struct co_list_hdr
{
    /// 指向下一个链表节点
    struct co_list_hdr *next;
};

/// 链表头的结构
struct co_list
{
    // 链表头节点
    struct co_list_hdr *first;
    // 链表尾节点
    struct co_list_hdr *last;

    // 链表中的节点个数
    uint32_t cnt;
    // 链表中最多节点数
    uint32_t maxcnt;
    // 链表中最少节点数
    uint32_t mincnt;
};
```

co_list表示链表头，存放了整个链表的一些元数据，链表节点为co_list_hdr，应用程序使用co_list时会在其特定结构体内部嵌入co_list_hdr和co_list。



### 链表初始化

co_list_init用于初始化一个链表

```
void __fastcall co_list_init(struct co_list *list)
{
  list->first = 0;
  list->last = 0;
  list->cnt = 0;
  list->maxcnt = 0;
  list->mincnt = -1;
}
```



### 插入节点

`co_list_push_back`用于将节点`list_hdr`插入到链表`list`的尾部

```
void __fastcall co_list_push_back(struct co_list *list, struct co_list_hdr *list_hdr)
{
  uint32_t cnt; // r1

  if ( list->first )
  {
    list->last->next = list_hdr;
  }
  else
  {
    list->first = list_hdr;
  }
  list->last = list_hdr;
  list_hdr->next = 0;
  cnt = list->cnt + 1;
  list->cnt = cnt;
  if ( list->maxcnt < cnt )
  {
    list->maxcnt = cnt;
  }
}
```

1. 如果`list->first`为空，就把`list_hdr`放到链表头`list->first`，否则就把该list_hdr放到最后一个节点的末尾
2. 最后更新`list->last`和`list->cnt` 

`co_list_push_front`用于将节点`list_hdr`插入到链表`list`的头部

```
void __fastcall co_list_push_front(struct co_list *list, struct co_list_hdr *list_hdr)
{
  co_list_hdr *v2; // r2
  uint32_t v3; // r1

  v2 = list->first;
  if ( !list->first )
  {
    list->last = list_hdr;
  }
  list_hdr->next = v2;
  list->first = list_hdr;
  v3 = list->cnt + 1;
  list->cnt = v3;
  if ( list->maxcnt < v3 )
  {
    list->maxcnt = v3;
  }
}
```

逻辑类似，就是把`list_hdr`放到链表`list->first`，然后修正`list`中相关的字段



节点出链表

co_list_pop_front将头节点出链表

```
struct co_list_hdr *__fastcall co_list_pop_front(struct co_list *list)
{
  struct co_list_hdr *item; // r1
  co_list_hdr *v2; // r2
  uint32_t v3; // r2

  item = list->first;
  if ( list->first )
  {
    v2 = item->next;
    list->first = item->next;
    if ( !v2 )
    {
      list->last = 0;
    }
    v3 = list->cnt - 1;
    list->cnt = v3;
    if ( list->mincnt > v3 )
    {
      list->mincnt = v3;
    }
  }
  return item;
}
```

就是把`list->first`的元素取出，然后修改list的相关信息。



### 取出节点

`co_list_extract`函数用于在`list`中取出从`list_hdr`开始的`nb_following`个节点。

```
bool __fastcall co_list_extract(struct co_list *list, struct co_list_hdr *list_hdr, int nb_following)
{
  bool has_found; // r5
  co_list_hdr *pre; // r4
  co_list_hdr *cur; // r3
  co_list_hdr *new_next; // r1
  uint32_t v7; // r1

  has_found = 0;
  pre = 0;
  for ( cur = list->first; cur; cur = cur->next )
  {
    if ( cur == list_hdr )                      // 首先找到 list_hdr 节点
    {
      has_found = 1;
      while ( nb_following > 0 )                // 从list_hdr开始取出nb_following个节点
      {
        cur = cur->next;
        --nb_following;  // 如果 nb_following 超过链表长度，就会空指针...
        --list->cnt;
      }
      new_next = cur->next;
      if ( pre )                                // list_hdr开始的nb_following个节点出链表
      {
        pre->next = new_next;
      }
      else
      {
        list->first = new_next;
      }
      if ( list->last == cur )
      {
        list->last = pre;
      }
      v7 = list->cnt - 1;
      list->cnt = v7;
      if ( list->mincnt > v7 )
      {
        list->mincnt = v7;
      }
      return has_found;
    }
    pre = cur;
  }
  return has_found;
}
```

主要逻辑就是找到list_hdr节点cur，然后从cur开始取出nb_following个节点。



### 查找节点

co_list_find就是遍历链表找到list_hdr节点

```
bool __fastcall co_list_find(struct co_list *list, struct co_list_hdr *list_hdr)
{
  do
  {
    list = list->first;
  }
  while ( list != list_hdr && list );
  return list == list_hdr;
}
```



### 链表合并

co_list_merge把两个链表合并为一个链表，实际就是把`list2`的元素挂在`list1`的末尾

```
void __fastcall co_list_merge(struct co_list *list1, struct co_list *list2)
{
  list1->last->next = list2->first;
  list1->last = list2->last;
  list2->first = 0;
  list1->cnt += list2->cnt;
  list2->cnt = 0;
}
```



# 消息调度机制

## 申请消息

函数通过ke_msg_alloc申请消息，入参分别为消息ID，目的task_id， 源task_id以及消息参数的长度。

```
void *__fastcall ke_msg_alloc(const ke_msg_id_t id, const ke_task_id_t dest_id, const ke_task_id_t src_id, const uint16_t param_len)
{
  size_t v6; // r4
  ke_msg *msg; // r0
  uint32_t *v9; // r5

  v6 = param_len;
  msg = ke_malloc(param_len + 16, 2);  // 申请内存
  msg->hdr.next = -1;
  msg->saved = 0;
  msg->id = id;
  msg->dest_id = dest_id;
  msg->src_id = src_id;
  msg->param_len = v6;
  v9 = msg->param;
  memset(msg->param, 0, v6);
  return v9;
}
```

返回值是一个ke_msg结构体的param部分

```
struct ke_msg
{
  struct co_list_hdr hdr;  // 链表头，用于后面把消息挂载到co_list链表中
  uint32_t saved;
  ke_msg_id_t id;
  ke_task_id_t dest_id;
  ke_task_id_t src_id;
  uint16_t param_len;  // param 的长度
  uint32_t param[1];
};
```

## 消息释放

ke_msg_free直接使用 ke_free 释放内存。

```
int __fastcall ke_msg_free(int a1)
{
  return ke_free(a1);
}
```

ke_msg_free的入参是 `ke_msg*`，但是`ke_msg_alloc`返回是`ke_msg`的`param`，所以在使用`ke_msg_free`很有可能出现指针没有减`0x10（ke_msg头部的大小）`的情况。

## 消息发送

ke_msg_send用于将特定消息发送到目标任务去处理

```
bool __fastcall ke_msg_send(int param)
{
  ke_msg *msg_hdr; // r1
  unsigned int v2; // r4

  msg_hdr = (param - 16);
  v2 = __get_CPSR();
  _R0 = 1;
  __asm { MSR.W           PRIMASK, R0 }         // 关闭中断
  co_list_push_back(p_ke_env, msg_hdr);
  _R0 = v2 != 0;
  __asm { MSR.W           PRIMASK, R0 }         // 恢复中断
  return ke_event_set(1u);
}
```

主要逻辑就是把msg_hdr放到p_ke_env链表头的末尾，p_ke_env指向ke_env，ke_env是一个全局变量，其结构如下

```
/// Kernel environment definition
struct ke_env_tag
{
    /// Queue of sent messages but not yet delivered to receiver
    struct co_list queue_sent;
    /// Queue of messages delivered but not consumed by receiver
    struct co_list queue_saved;
    /// Queue of timers
    struct co_list queue_timer;

    #if (KE_MEM_RW)
    /// Root pointer = pointer to first element of heap linked lists
    struct mblock_free * heap[KE_MEM_BLOCK_MAX];
    /// Size of heaps
    uint16_t heap_size[KE_MEM_BLOCK_MAX];

    #if (KE_PROFILING)
    /// Size of heap used
    uint16_t heap_used[KE_MEM_BLOCK_MAX];
    /// Maximum heap memory used
    uint32_t max_heap_used;
    #endif //KE_PROFILING
    #endif //KE_MEM_RW
};
```

可以看的结构体头部是`queue_sent`，类型为`co_list`，这个队列用于存放发送的的消息，`queue_sent`中消息会在后面消息调度时，找到对应的消息处理函数进行处理。

故`ke_msg_send`就是把要发送的消息放到`ke_env`的`queue_sent`发送队列中。

消息挂载到发送队列后会调用ke_event_set通知内核，1号事件触发，然后在事件处理函数中会去调用消息对应的处理函数去处理消息。



# 问题

`co_list_extract` 取出节点时如果数目过多会空指针解引用。

ke_msg_free的入参是 `ke_msg*`，但是`ke_msg_alloc`返回是`ke_msg`的`param`，所以在使用`ke_msg_free`很有可能出现指针没有减`0x10（ke_msg头部的大小）`的情况。



